






初始点：
初始获取数据：googlemaps路径信息、路径上的点具体坐标
初始计算数据：每个点到下一个点的距离，以及到下一个点的角度
实时获取数据：用户实时坐标，用户实时手机指向角度
            ——程序——
计算后及输出数据：调整角度in degrees。

程序：
googlemaps给出的路径上的每个点都作为一个圆心
将其作为圆心并作一个半径比如1m或者2m左右的圆为阈值1
作一条其与下一个圆心的连线，得出其与+x轴夹角（以+x轴为0）
以两圆心为origin，作两条直径垂直于连线，使其平行，并可得出一个平行四边形
这个平行四边形再减去下个点阈值1的部分，即为阈值2
若用户试试坐标不在阈值1或阈值2之内，则为阈值3
若用户在阈值3，则再从初始点开始重新跑。
若用户在阈值1或阈值2，则给用户导向该阈值点的下一个点（导向本阈值点指向下一阈值点的同一角度）。


ok perfect! 继续下一步，我想写一个有点复杂的用户实时位置和实时手机朝向与路径点上的信息的对比，具体是：
每个路径点都有2个阈值，
googlemaps给出的路径上的每个点都作为一个圆心，
将没给点都作为圆心并作一个半径为现实距离2米的圆，每个路径点作的圆包含的面积都为该路径点的阈值1。
每两个路径点再作一个平行四边形，
以第一个路径点为平行四边形一条宽边的中点，下一个路径点为平行四边形的另一条宽边的中点，
两条宽边都应该互相平行并且长度都为4米，并且与第一个point的变量angle为垂直。
连接两条宽边，使其成为一个平行四边形。
每个平行四边形都会与第一个路径点的阈值1部分重合，并与第二个路径点的阈值1部分重合，
减去与连个阈值1重合的部分，就得出了第一个路径点的阈值2，以此类推。
若用户在阈值3则表示用户实时位置不任意路径点上的阈值1或阈值2中。
实时监测用户坐标（GPS)，
若用户实时坐标不在阈值1或阈值2之内，则为阈值3。
若用户实时坐标在一个路径点的阈值1或者阈值2以内，则print该路径点的变量angle
若用户实时坐标在阈值3，则保留路径终点，以用户当前坐标为起点，输入谷歌地图中得出新的路径信息。
循环这整个逻辑。
如果你有任何问题或者哪里我没有讲清楚，你可以问我。







现在我要根据已有的代码添加一个新的功能，那就是实时检测以及对比用户的实时位置（经纬度坐标）与路径点阈值。
你现在有一条路径，路径由一系列的路径点（Point）构成，每个点都有一个：
    •    阈值1（圆）：
    •    以每个路径点为圆心、半径2米的圆区域。
    •    当用户实时位置在这个区域内，表示用户处于该点的阈值1区域中。
    •    阈值2（平行四边形）：
    •    对于每两个相邻路径点A和B：
    •    以点A作为第一个平行四边形宽边（4米）的中点，点B作为第二个宽边（4米）的中点。
    •    两条宽边长度都是4米，且相互平行。
    •    宽边方向（垂直于Point类中的angle角度，即路径点指向下一个点的角度）。
    •    连接两条宽边构成一个平行四边形。
    •    阈值2区域 = 这个平行四边形减去它与两个圆形阈值1区域的交集部分。
    •    阈值3：
    •    用户实时坐标不在任何路径点的阈值1或阈值2区域内时，即表示用户处于阈值3。
    •    当用户处于阈值3时，重新调用谷歌地图API，以当前实时坐标为起点、路径终点为终点，重新计算路径，更新路径信息。

⸻

实时监测用户坐标：
     如果用户在多个点的阈值1内，则打印出index最大的路径点的angle值
    •    若用户位于阈值1或阈值2中：
    •    打印此路径点的angle。
    •    若用户位于阈值3中：
    •    重新以当前用户坐标为起点，路径终点为终点，调用谷歌地图API请求新路径。
    •    此逻辑不断循环实时更新。








现在我的代码中已经定义了阈值1、阈值2以及阈值3，你需要在目前的代码上增加实时检测的功能。



